### 1. 代码功能与使用场景总结
这段代码是基于`Starlette/FastAPI`框架的**自定义中间件集合**, 核心作用是为所有API请求提供“统一的前置/后置处理能力”, 相当于项目的“请求网关”——所有客户端请求都会先经过这些中间件处理, 再到达具体的接口逻辑, 处理完成后再通过中间件返回响应。
核心功能+使用场景: 
- `CustomCORSMiddleware`: 处理跨域请求(前端和后端域名不同时, 解决浏览器的跨域限制)；
- `RequestLogMiddleware`: 核心中间件, 既记录全量请求/响应日志(便于排查问题), 又实现安全拦截(IP黑白名单、演示模式下禁止非GET操作)；
- `CustomGZipMiddleware`: 自动压缩响应数据(减少网络传输大小, 提升接口响应速度)；
使用场景: FastAPI后端服务启动时注册这些中间件, 覆盖所有接口的请求生命周期, 无需在每个接口里重复写跨域、日志、压缩逻辑。

### 2. 核心模块拆分与逐一解释(类比: 小区门禁系统)
把整个请求流程类比成“访客进入小区”: 
- 中间件 = 小区门口的“功能岗亭”(所有访客必须经过)；
- `Request` = 访客；
- `Response` = 访客离开时的回执；
- `dispatch`方法 = 岗亭的“核心处理流程”；
- `call_next` = 岗亭放行后, 访客前往具体楼栋(接口逻辑)。

#### 模块1: 依赖导入(岗亭的工具准备)
```python
import json
import time

from starlette.middleware.base import (
    BaseHTTPMiddleware,
    RequestResponseEndpoint,
)
from starlette.middleware.cors import CORSMiddleware
from starlette.middleware.gzip import GZipMiddleware
from starlette.requests import Request
from starlette.responses import Response
from starlette.types import ASGIApp

from app.api.v1.module_system.params.service import ParamsService
from app.common.response import ErrorResponse
from app.config.setting import settings
from app.core.exceptions import CustomException
from app.core.logger import log
from app.core.security import decode_access_token
```
- 解释: 
  - 基础工具: `json`(解析Token中的用户信息)、`time`(计算请求处理耗时)；
  - Starlette核心: `BaseHTTPMiddleware`(自定义中间件的基类)、`Request/Response`(请求/响应对象)、`ASGIApp`(FastAPI/Starlette的应用实例类型, 类比“小区的总控系统”)、`RequestResponseEndpoint`(下一个中间件/接口逻辑的“入口”, 类比“楼栋入口”)；
  - 内置中间件基类: `CORSMiddleware`(跨域处理)、`GZipMiddleware`(压缩处理)；
  - 项目依赖: 配置(`settings`)、日志(`log`)、Token解码(`decode_access_token`)、异常类(`CustomException`)、响应格式(`ErrorResponse`)、系统配置服务(`ParamsService`)。

#### 模块2: CustomCORSMiddleware(跨域岗亭)
```python
class CustomCORSMiddleware(CORSMiddleware):
    """CORS跨域中间件"""

    def __init__(self, app: ASGIApp) -> None:
        super().__init__(
            app,
            allow_origins=settings.ALLOW_ORIGINS,
            allow_methods=settings.ALLOW_METHODS,
            allow_headers=settings.ALLOW_HEADERS,
            allow_credentials=settings.ALLOW_CREDENTIALS,
            expose_headers=settings.CORS_EXPOSE_HEADERS,
        )
```
- 解释: 类比“小区岗亭允许外部访客(前端)进入的规则”: 
  - 继承`CORSMiddleware`(Starlette内置的跨域处理基类), 相当于“复用小区现成的跨域规则模板”；
  - `__init__`方法中从`settings`读取跨域配置(允许的域名、请求方法、请求头), 统一配置跨域规则, 避免重复写死；
  - 核心作用: 解决前端和后端域名不同时, 浏览器的“跨域资源共享(CORS)”限制(比如前端在`localhost:3000`, 后端在`localhost:8001`, 不加跨域中间件会报CORS错误)。

#### 模块3: RequestLogMiddleware(日志+安全拦截岗亭, 核心)
这是整个代码的核心, 负责“记录访客日志+拦截违规访客”, 拆分子模块解释: 

##### 子模块3.1: _extract_session_id_from_request(提取访客身份证)
```python
@staticmethod
def _extract_session_id_from_request(request: Request) -> str | None:
    """从请求中提取session_id(支持从Token或已设置的scope中获取)"""
    # 1. 先检查 scope 中是否已经有 session_id(登录接口会设置)
    session_id = request.scope.get("session_id")
    if session_id:
        return session_id

    # 2. 尝试从 Authorization Header 中提取
    try:
        authorization = request.headers.get("Authorization")
        if not authorization:
            return None

        # 处理Bearer token
        token = authorization.replace("Bearer ", "").strip()

        # 解码token
        payload = decode_access_token(token)
        if not payload or not hasattr(payload, "sub"):
            return None

        # 从payload中提取session_id
        user_info = json.loads(payload.sub)
        session_id = user_info.get("session_id")

        # 同时设置到request.scope中, 避免后续重复解析
        if session_id:
            request.scope["session_id"] = session_id

        return session_id
    except Exception:
        # 解析失败静默处理, 返回None(可能是未认证请求)
        return None
```
- 解释: 类比“岗亭读取访客的身份证号(session_id), 便于后续追踪”: 
  - `request.scope`: Starlette的“请求上下文”, 类比“访客的临时档案袋”, 可以存储请求全程的临时数据(比如解析后的session_id, 避免重复解析Token)；
  - 逻辑: 先看档案袋里有没有身份证号(已解析过)→ 没有就从请求头的`Authorization`(Token)中解析→ 解析失败返回None(未登录/无效Token的请求)；
  - 核心价值: 给每个请求绑定唯一的session_id, 日志中能精准追踪“哪个用户/会话发起的请求”。

##### 子模块3.2: dispatch(岗亭核心处理流程)
`dispatch`是`BaseHTTPMiddleware`的核心方法, 所有请求都会走这个方法, 类比“岗亭对访客的完整处理流程”: 
```python
async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
    start_time = time.time()  # 记录访客进入岗亭的时间

    # 1. 提取session_id(访客身份证)
    session_id = self._extract_session_id_from_request(request)

    # 2. 记录基础请求日志(登记访客信息)
    log_fields = (
        f"请求来源: {request.client.host if request.client else '未知'},"
        f"请求方法: {request.method},"
        f"请求路径: {request.url.path}"
    )
    log.info(log_fields)

    try:
        response = None

        # 3. 获取请求路径和客户端真实IP(确定访客是谁、要去哪)
        path = request.scope.get("path")
        request_ip = (
            x_forwarded_for.split(",")[0].strip()
            if (x_forwarded_for := request.headers.get("X-Forwarded-For"))
            else request.client.host
            if request.client
            else None
        )

        # 4. 从Redis获取系统配置(读取小区的安全规则: 黑白名单、演示模式)
        demo_enable = False
        ip_white_list = []
        white_api_list_path = []
        ip_black_list = []
        try:
            redis = request.app.state.redis  # 从应用实例获取Redis连接(小区的规则数据库)
            system_config = await ParamsService.get_system_config_for_middleware(redis)
            demo_enable = system_config["demo_enable"]
            ip_white_list = system_config["ip_white_list"]
            white_api_list_path = system_config["white_api_list_path"]
            ip_black_list = system_config["ip_black_list"]
        except Exception as e:
            log.error(f"获取系统配置失败: {e}")

        # 5. 安全拦截逻辑(检查访客是否违规)
        should_block = False
        block_reason = ""
        # 5.1 检查IP是否在黑名单(禁止的访客)
        if request_ip and request_ip in ip_black_list:
            should_block = True
            block_reason = f"IP地址 {request_ip} 在黑名单中"
        # 5.2 演示模式下拦截非GET请求(仅允许查看, 禁止操作)
        elif demo_enable in ["true", "True"] and request.method != "GET":
            is_ip_whitelisted = request_ip in ip_white_list
            is_path_whitelisted = path in white_api_list_path
            if not is_ip_whitelisted and not is_path_whitelisted:
                should_block = True
                block_reason = f"演示模式下拦截非GET请求, IP: {request_ip}, 路径: {path}"

        # 6. 拦截违规请求(拒绝访客进入)
        if should_block:
            log.warning([f"会话ID: {session_id or '未认证'}", f"请求被拦截: {block_reason}", ...])
            return ErrorResponse(msg="演示环境, 禁止操作")

        # 7. 放行请求(访客前往具体楼栋)
        response = await call_next(request)

        # 8. 记录响应日志(登记访客离开信息)
        process_time = round(time.time() - start_time, 5)
        response.headers["X-Process-Time"] = str(process_time)  # 给回执加处理耗时
        content_length = response.headers.get("content-length", "0")
        response_info = f"响应状态: {response.status_code}, 响应内容长度: {content_length}, 处理时间: {round(process_time * 1000, 3)}ms"
        log.info(response_info)

        return response

    # 9. 异常处理(岗亭处理出错)
    except CustomException as e:
        log.error(f"中间件处理异常: {e!s}")
        return ErrorResponse(msg="系统异常, 请联系管理员", data=str(e))
```
- 核心逻辑拆解(访客流程): 
  1. 登记基础信息 → 2. 查安全规则 → 3. 检查是否违规 → 4. 违规则拒绝 → 5. 合规则放行 → 6. 记录离开信息；
- 关键概念: 
  - `call_next`: 类比“岗亭放行后, 访客前往具体楼栋的入口”, 调用后会执行下一个中间件/接口逻辑, 返回响应；
  - `X-Forwarded-For`: 获取客户端真实IP(如果后端有Nginx反向代理, `request.client.host`会是代理服务器IP, 需要从这个请求头取真实IP)；
  - 演示模式拦截: 只允许`GET`请求(查数据), 禁止`POST/PUT/DELETE`(改数据), 仅白名单IP/路径可例外。

#### 模块4: CustomGZipMiddleware(压缩岗亭)
```python
class CustomGZipMiddleware(GZipMiddleware):
    """GZip压缩中间件"""

    def __init__(self, app: ASGIApp) -> None:
        super().__init__(
            app,
            minimum_size=settings.GZIP_MIN_SIZE,
            compresslevel=settings.GZIP_COMPRESS_LEVEL,
        )
```
- 解释: 类比“小区快递站给包裹压缩打包, 减少运输体积”: 
  - 继承`GZipMiddleware`(Starlette内置的压缩中间件), 从`settings`读取压缩规则；
  - `minimum_size`: 只有响应数据大于这个值(比如1000字节)才压缩(小数据压缩反而会变大)；
  - `compresslevel`: 压缩级别(1-9, 9压缩率最高但耗时稍长)；
  - 核心作用: 自动压缩JSON、HTML等响应数据, 减少网络传输量, 提升前端加载速度。

### 3. 抽象概念类比理解
| 抽象概念                | 类比场景                | 理解说明                                  |
|-------------------------|-------------------------|-------------------------------------------|
| ASGIApp                 | 小区的总控系统          | FastAPI/Starlette应用实例, 中间件挂载的载体 |
| Request.scope           | 访客的临时档案袋        | 存储请求全程的临时数据(session_id、路径) |
| RequestResponseEndpoint | 楼栋入口                | 下一个中间件/接口逻辑的入口                |
| dispatch方法            | 岗亭的核心处理流程      | 所有请求必须经过的中间件逻辑              |
| call_next               | 岗亭放行按钮            | 调用后执行后续逻辑, 返回响应              |

### 总结
1. 核心定位: 三个自定义中间件覆盖“跨域、日志+安全拦截、GZip压缩”三大核心能力, 是FastAPI项目的“请求统一处理层”；
2. 核心逻辑: 
   - 跨域: 复用内置基类, 从配置读取规则；
   - 日志+拦截: 记录请求/响应日志, 基于IP黑白名单、演示模式拦截违规请求；
   - 压缩: 自动压缩大响应数据, 优化传输性能；
3. 关键价值: 无需在每个接口重复写通用逻辑, 统一管控所有请求, 提升代码复用性和可维护性。